{
  "version": 3,
  "sources": ["../../@ledgerhq/devices/src/hid-framing.ts", "../../@ledgerhq/hw-transport-webhid/src/TransportWebHID.ts", "../../@ledgerhq/devices/src/index.ts", "../../@ledgerhq/logs/src/index.ts"],
  "sourcesContent": ["import { TransportError } from \"@ledgerhq/errors\";\nexport type ResponseAcc =\n  | {\n      data: Buffer;\n      dataLength: number;\n      sequence: number;\n    }\n  | null\n  | undefined;\nconst Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0,\n};\n\n/**\n *\n */\nconst createHIDframing = (channel: number, packetSize: number) => {\n  return {\n    makeBlocks(apdu: Buffer): Buffer[] {\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([\n        data, // fill data with padding\n        Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0),\n      ]);\n      const blocks: Buffer[] = [];\n\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n\n      return blocks;\n    },\n\n    reduceResponse(acc: ResponseAcc, chunk: Buffer): ResponseAcc {\n      let { data, dataLength, sequence } = acc || initialAcc;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n\n      sequence++;\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data,\n        dataLength,\n        sequence,\n      };\n    },\n\n    getReducedResult(acc: ResponseAcc): Buffer | null | undefined {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    },\n  };\n};\n\nexport default createHIDframing;\n", "import Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n  TransportError,\n} from \"@ledgerhq/errors\";\n\nconst ledgerDevices = [\n  {\n    vendorId: ledgerUSBVendorId,\n  },\n];\n\nconst isSupported = () =>\n  Promise.resolve(!!(window.navigator && window.navigator.hid));\n\nconst getHID = (): HID => {\n  // $FlowFixMe\n  const { hid } = navigator;\n  if (!hid)\n    throw new TransportError(\n      \"navigator.hid is not supported\",\n      \"HIDNotSupported\"\n    );\n  return hid;\n};\n\nasync function requestLedgerDevices(): Promise<HIDDevice[]> {\n  const device = await getHID().requestDevice({\n    filters: ledgerDevices,\n  });\n  if (Array.isArray(device)) return device;\n  return [device];\n}\n\nasync function getLedgerDevices(): Promise<HIDDevice[]> {\n  const devices = await getHID().getDevices();\n  return devices.filter((d) => d.vendorId === ledgerUSBVendorId);\n}\n\nasync function getFirstLedgerDevice(): Promise<HIDDevice> {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  const devices = await requestLedgerDevices();\n  return devices[0];\n}\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\n\nexport default class TransportWebHID extends Transport {\n  device: HIDDevice;\n  deviceModel: DeviceModel | null | undefined;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n\n  constructor(device: HIDDevice) {\n    super();\n    this.device = device;\n    this.deviceModel =\n      typeof device.productId === \"number\"\n        ? identifyUSBProductId(device.productId)\n        : undefined;\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n\n  inputs: Buffer[] = [];\n  inputCallback: ((arg0: Buffer) => void) | null | undefined;\n  read = (): Promise<Buffer> => {\n    if (this.inputs.length) {\n      return Promise.resolve((this.inputs.shift() as unknown) as Buffer);\n    }\n\n    return new Promise((success) => {\n      this.inputCallback = success;\n    });\n  };\n  onInputReport = (e: HIDInputReportEvent) => {\n    const buffer = Buffer.from(e.data.buffer);\n\n    if (this.inputCallback) {\n      this.inputCallback(buffer);\n      this.inputCallback = null;\n    } else {\n      this.inputs.push(buffer);\n    }\n  };\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<HIDDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      (device) => {\n        if (!device) {\n          observer.error(\n            new TransportOpenUserCancelled(\"Access denied to use Ledger device\")\n          );\n        } else if (!unsubscribed) {\n          const deviceModel =\n            typeof device.productId === \"number\"\n              ? identifyUSBProductId(device.productId)\n              : undefined;\n          observer.next({\n            type: \"add\",\n            descriptor: device,\n            deviceModel,\n          });\n          observer.complete();\n        }\n      },\n      (error) => {\n        observer.error(new TransportOpenUserCancelled(error.message));\n      }\n    );\n\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n\n    return {\n      unsubscribe,\n    };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const [device] = await requestLedgerDevices();\n    return TransportWebHID.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebHID.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n  static async open(device: HIDDevice) {\n    await device.open();\n    const transport = new TransportWebHID(device);\n\n    const onDisconnect = (e) => {\n      if (device === e.device) {\n        getHID().removeEventListener(\"disconnect\", onDisconnect);\n\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n\n    getHID().addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    this.device.removeEventListener(\"inputreport\", this.onInputReport);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = async (apdu: Buffer): Promise<Buffer> => {\n    const b = await this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize);\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.sendReport(0, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n\n      while (!(result = framing.getReducedResult(acc))) {\n        const buffer = await this.read();\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch((e) => {\n      if (e && e.message && e.message.includes(\"write\")) {\n        this._emitDisconnect(e);\n\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n\n      throw e;\n    });\n    return b as Buffer;\n  };\n\n  setScrambleKey() {}\n}\n", "import semver from \"semver\";\n\n/**\n * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)\n *\n ** Model\n * Ledger Nano S : 0x10\n * Ledger Blue : 0x00\n * Ledger Nano X : 0x40\n *\n ** Interface support bitfield\n * Generic HID : 0x01\n * Keyboard HID : 0x02\n * U2F : 0x04\n * CCID : 0x08\n * WebUSB : 0x10\n */\nexport const IIGenericHID = 0x01;\nexport const IIKeyboardHID = 0x02;\nexport const IIU2F = 0x04;\nexport const IICCID = 0x08;\nexport const IIWebUSB = 0x10;\n\nexport enum DeviceModelId {\n  blue = \"blue\",\n  nanoS = \"nanoS\",\n  nanoSP = \"nanoSP\",\n  nanoX = \"nanoX\",\n  nanoFTS = \"nanoFTS\",\n}\n\nconst devices: { [key in DeviceModelId]: DeviceModel } = {\n  [DeviceModelId.blue]: {\n    id: DeviceModelId.blue,\n    productName: \"Ledger Blue\",\n    productIdMM: 0x00,\n    legacyUsbProductId: 0x0000,\n    usbOnly: true,\n    memorySize: 480 * 1024,\n    masks: [0x31000000, 0x31010000],\n    getBlockSize: (_firwareVersion: string): number => 4 * 1024,\n  },\n  [DeviceModelId.nanoS]: {\n    id: DeviceModelId.nanoS,\n    productName: \"Ledger Nano S\",\n    productIdMM: 0x10,\n    legacyUsbProductId: 0x0001,\n    usbOnly: true,\n    memorySize: 320 * 1024,\n    masks: [0x31100000],\n    getBlockSize: (firmwareVersion: string): number =>\n      semver.lt(semver.coerce(firmwareVersion) ?? \"\", \"2.0.0\")\n        ? 4 * 1024\n        : 2 * 1024,\n  },\n  [DeviceModelId.nanoSP]: {\n    id: DeviceModelId.nanoSP,\n    productName: \"Ledger Nano S Plus\",\n    productIdMM: 0x50,\n    legacyUsbProductId: 0x0005,\n    usbOnly: true,\n    memorySize: 1536 * 1024,\n    masks: [0x33100000],\n    getBlockSize: (_firmwareVersion: string): number => 32,\n  },\n  [DeviceModelId.nanoX]: {\n    id: DeviceModelId.nanoX,\n    productName: \"Ledger Nano X\",\n    productIdMM: 0x40,\n    legacyUsbProductId: 0x0004,\n    usbOnly: false,\n    memorySize: 2 * 1024 * 1024,\n    masks: [0x33000000],\n    getBlockSize: (_firwareVersion: string): number => 4 * 1024,\n    bluetoothSpec: [\n      {\n        serviceUuid: \"13d63400-2c97-0004-0000-4c6564676572\",\n        notifyUuid: \"13d63400-2c97-0004-0001-4c6564676572\",\n        writeUuid: \"13d63400-2c97-0004-0002-4c6564676572\",\n        writeCmdUuid: \"13d63400-2c97-0004-0003-4c6564676572\",\n      },\n    ],\n  },\n  [DeviceModelId.nanoFTS]: {\n    id: DeviceModelId.nanoFTS,\n    productName: \"Ledger Nano FTS\",\n    productIdMM: 0x60,\n    legacyUsbProductId: 0x0006,\n    usbOnly: false,\n    memorySize: 2 * 1024 * 1024, // ← ↓ TODO Update with actual values\n    masks: [0x33200000],\n    getBlockSize: (_firwareVersion: string): number => 4 * 1024,\n    bluetoothSpec: [\n      {\n        serviceUuid: \"13d63400-2c97-6004-0000-4c6564676572\",\n        notifyUuid: \"13d63400-2c97-6004-0001-4c6564676572\",\n        writeUuid: \"13d63400-2c97-6004-0002-4c6564676572\",\n        writeCmdUuid: \"13d63400-2c97-6004-0003-4c6564676572\",\n      },\n    ],\n  },\n};\n\nconst productMap = {\n  Blue: DeviceModelId.blue,\n  \"Nano S\": DeviceModelId.nanoS,\n  \"Nano S Plus\": DeviceModelId.nanoSP,\n  \"Nano X\": DeviceModelId.nanoX,\n  \"Nano FTS\": DeviceModelId.nanoFTS,\n};\n\nconst devicesList: DeviceModel[] = Object.values(devices);\n\n/**\n *\n */\nexport const ledgerUSBVendorId = 0x2c97;\n\n/**\n *\n */\nexport const getDeviceModel = (id: DeviceModelId): DeviceModel => {\n  const info = devices[id];\n  if (!info) throw new Error(\"device '\" + id + \"' does not exist\");\n  return info;\n};\n\n/**\n * Given a `targetId`, return the deviceModel associated to it,\n * based on the first two bytes.\n */\nexport const identifyTargetId = (\n  targetId: number\n): DeviceModel | null | undefined => {\n  const deviceModel = devicesList.find(({ masks }) =>\n    masks.find((mask) => (targetId & 0xffff0000) === mask)\n  );\n\n  return deviceModel;\n};\n\n/**\n *\n */\nexport const identifyUSBProductId = (\n  usbProductId: number\n): DeviceModel | null | undefined => {\n  const legacy = devicesList.find((d) => d.legacyUsbProductId === usbProductId);\n  if (legacy) return legacy;\n  const mm = usbProductId >> 8;\n  const deviceModel = devicesList.find((d) => d.productIdMM === mm);\n  return deviceModel;\n};\n\nexport const identifyProductName = (\n  productName: string\n): DeviceModel | null | undefined => {\n  const deviceModel = devicesList.find((d) => d.id === productMap[productName]);\n  return deviceModel;\n};\n\nconst bluetoothServices: string[] = [];\nconst serviceUuidToInfos: Record<string, BluetoothInfos> = {};\n\nfor (const id in devices) {\n  const deviceModel = devices[id];\n  const { bluetoothSpec } = deviceModel;\n  if (bluetoothSpec) {\n    for (let i = 0; i < bluetoothSpec.length; i++) {\n      const spec = bluetoothSpec[i];\n      bluetoothServices.push(spec.serviceUuid);\n      serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[\n        spec.serviceUuid.replace(/-/g, \"\")\n      ] = {\n        deviceModel,\n        ...spec,\n      };\n    }\n  }\n}\n\n/**\n *\n */\nexport const getBluetoothServiceUuids = (): string[] => bluetoothServices;\n\n/**\n *\n */\nexport const getInfosForServiceUuid = (\n  uuid: string\n): BluetoothInfos | undefined => serviceUuidToInfos[uuid.toLowerCase()];\n\n/**\n *\n */\nexport interface DeviceModel {\n  id: DeviceModelId;\n  productName: string;\n  productIdMM: number;\n  legacyUsbProductId: number;\n  usbOnly: boolean;\n  memorySize: number;\n  masks: number[];\n  // blockSize: number, // THIS FIELD IS DEPRECATED, use getBlockSize\n  getBlockSize: (firmwareVersion: string) => number;\n  bluetoothSpec?: {\n    serviceUuid: string;\n    writeUuid: string;\n    writeCmdUuid: string;\n    notifyUuid: string;\n  }[];\n}\n\n/**\n *\n */\nexport interface BluetoothInfos {\n  deviceModel: DeviceModel;\n  serviceUuid: string;\n  writeUuid: string;\n  writeCmdUuid: string;\n  notifyUuid: string;\n}\n", "export type TraceContext = Record<string, unknown>;\nexport type LogData = any;\nexport type LogType = string;\n\n/**\n * A Log object\n */\nexport interface Log {\n  /**\n   * A namespaced identifier of the log (not a level like \"debug\", \"error\" but more like \"apdu\", \"hw\", etc...)\n   */\n  type: LogType;\n  message?: string;\n  /**\n   * Data associated to the log event\n   */\n  data?: LogData;\n  /**\n   * Context data, coming for example from the caller's parent, to enable a simple tracing system\n   */\n  context?: TraceContext;\n  /**\n   * Unique id among all logs\n   */\n  id: string;\n  /*\n   * Date when the log occurred\n   */\n  date: Date;\n}\n\nexport type Unsubscribe = () => void;\nexport type Subscriber = (arg0: Log) => void;\n\nlet id = 0;\nconst subscribers: Subscriber[] = [];\n\n/**\n * Logs something\n *\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nexport const log = (type: LogType, message?: string, data?: LogData) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  dispatch(obj);\n};\n\n/**\n * A simple tracer function, only expanding the existing log function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param context Anything representing the context where the log occurred\n */\nexport const trace = ({\n  type,\n  message,\n  data,\n  context,\n}: {\n  type: LogType;\n  message?: string;\n  data?: LogData;\n  context?: TraceContext;\n}) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  if (context) obj.context = context;\n\n  dispatch(obj);\n};\n\n/**\n * A simple tracer class, that can be used to avoid repetition when using the `trace` function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param type A given type (not level) for the current local tracer (\"hw\", \"withDevice\", etc.)\n * @param context Anything representing the context where the log occurred\n */\nexport class LocalTracer {\n  constructor(\n    private type: LogType,\n    private context?: TraceContext,\n  ) {}\n\n  trace(message: string, data?: TraceContext) {\n    trace({\n      type: this.type,\n      message,\n      data,\n      context: this.context,\n    });\n  }\n\n  getContext(): TraceContext | undefined {\n    return this.context;\n  }\n\n  setContext(context?: TraceContext) {\n    this.context = context;\n  }\n\n  updateContext(contextToAdd: TraceContext) {\n    this.context = { ...this.context, ...contextToAdd };\n  }\n\n  getType(): LogType {\n    return this.type;\n  }\n\n  setType(type: LogType) {\n    this.type = type;\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `type`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withType(type: LogType): LocalTracer {\n    return new LocalTracer(type, this.context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with a new `context`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  withContext(context?: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `context`,\n   * on which an additional context is merged with the existing one.\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withUpdatedContext(contextToAdd: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, { ...this.context, ...contextToAdd });\n  }\n}\n\n/**\n * Adds a subscribers to the emitted logs.\n *\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nexport const listen = (cb: Subscriber): Unsubscribe => {\n  subscribers.push(cb);\n  return () => {\n    const i = subscribers.indexOf(cb);\n\n    if (i !== -1) {\n      // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n      subscribers[i] = subscribers[subscribers.length - 1];\n      subscribers.pop();\n    }\n  };\n};\n\nfunction dispatch(log: Log) {\n  for (let i = 0; i < subscribers.length; i++) {\n    try {\n      subscribers[i](log);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n\n// for debug purpose\n\ndeclare global {\n  interface Window {\n    __ledgerLogsListen: any;\n  }\n}\n\nif (typeof window !== \"undefined\") {\n  window.__ledgerLogsListen = listen;\n}\n"],
  "mappings": "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",
  "names": ["_a", "DeviceModelId", "semver", "_a", "id", "log", "_a", "devices", "TransportWebHID", "_this", "hidFraming"]
}
